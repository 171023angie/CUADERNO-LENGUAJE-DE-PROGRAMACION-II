# üß† Cuaderno Virtual ‚Äì Lenguaje de Programaci√≥n

**Nombre:** Gleny Ang√©lica Condori Mamani  
**Facultad:** Ingenier√≠a Estad√≠stica e Inform√°tica  
**Universidad:** Universidad Nacional del Altiplano ‚Äì Puno  
**Curso:** Lenguaje de Programaci√≥n (Python)  
**Docente:** Leonel  
## üìòTEMA  _ PROGRAMACION ORIENTADA A OBJETOS
Es una paradigma de programacion que organiza el sofware entorno a objetos ,los cuales conbinan datos(atributos)y comportamiento(metodos)en una misma entidad.Estos objetos se basan en clases que funcionan como molde o plantillas que definen sus caracteristicas y acciones.
## Diferencia entre programacion estructurada y P.O.O
## üß© Comparaci√≥n: Programaci√≥n Estructurada vs Programaci√≥n Orientada a Objetos

| **Caracter√≠stica** | **Programaci√≥n Estructurada** | **Programaci√≥n Orientada a Objetos (POO)** |
|---------------------|-------------------------------|---------------------------------------------|
| **Paradigma** | Se basa en procedimientos y funciones que operan sobre datos. | Se basa en objetos que combinan datos y comportamiento. |
| **Organizaci√≥n del C√≥digo** | El programa se divide en funciones o m√≥dulos. | El programa se organiza en **clases** y **objetos**. |
| **Enfoque** | Orientado a **procesos**: la secuencia de instrucciones es lo principal. | Orientado a **entidades**: los objetos del mundo real son lo principal. |
| **Datos** | Los datos son **globales o compartidos**, y pueden ser modificados por cualquier funci√≥n. | Los datos (**atributos**) est√°n **encapsulados** dentro de los objetos y solo son accesibles mediante sus m√©todos. |
| **Reutilizaci√≥n** | **Baja:** se requiere repetir o copiar funciones. | **Alta:** gracias a la **herencia** y **polimorfismo**. |
| **Mantenimiento** | **Dif√≠cil**, porque un cambio en los datos puede afectar muchas funciones. | **M√°s sencillo**, ya que los cambios se a√≠slan en las clases u objetos correspondientes. |

## üß© ¬øQu√© es la Programaci√≥n Orientada a Objetos?

La **POO** es un paradigma de programaci√≥n que organiza el c√≥digo en **clases y objetos**.  
- **Clase:** molde o plantilla que define las caracter√≠sticas y comportamientos de un tipo de objeto.  
- **Objeto:** instancia concreta de una clase.  
- **Atributo:** caracter√≠sticas o propiedades del objeto.  
- **M√©todo:** funciones que describen el comportamiento del objeto.
## EN RESUMEN 
-La paradigma estructurada organiza en funciones y pasos esenciales siendo mas adecuado para programas peque√±os y sencillos.

-La P.O.O organiza el software en clases y objetos,lo cual facilita modularidad , reutilizacion y escalavilidad ,siendo la mas usada en sistemas modernos.
## üåü Ventajas de la Programaci√≥n Orientada a Objetos (P.O.O.)

| **Ventaja** | **Descripci√≥n** |
|--------------|----------------|
| **Modularidad** | El c√≥digo se organiza en **clases y objetos**, lo que facilita la comprensi√≥n, depuraci√≥n y mantenimiento del sistema. |
| **Reutilizaci√≥n de C√≥digo** | Gracias a la **herencia** y al **polimorfismo**, se pueden crear nuevas clases a partir de otras sin repetir c√≥digo. |
| **Encapsulamiento** | Protege los datos internos de los objetos, permitiendo el acceso solo a trav√©s de m√©todos definidos, manteniendo la seguridad de la informaci√≥n. |
| **Abstracci√≥n** | Permite representar entidades del mundo real como modelos computacionales, simplificando la complejidad. |
| **Escalabilidad** | Adecuado para sistemas grandes y complejos, ya que permite dividir el trabajo en m√≥dulos independientes. |
| **Mantenimiento m√°s sencillo** | Los cambios se realizan en clases espec√≠ficas sin afectar todo el sistema. |
| **Flexibilidad y Extensibilidad** | Permite adaptar y ampliar sistemas de manera r√°pida y ordenada. |
| **Productividad** | Facilita el trabajo en equipo: varios programadores pueden desarrollar distintas clases u objetos de forma independiente. |

---

## üíª Aplicaciones de la Programaci√≥n Orientada a Objetos

La **P.O.O.** se aplica ampliamente en el desarrollo de software moderno, ya que permite construir **sistemas modulares, reutilizables y escalables**.  
A continuaci√≥n, algunos ejemplos destacados:

- üñ•Ô∏è **1)Desarrollo de aplicaciones de escritorio:**  
  Programas de editores de texto, hojas de c√°lculo de  software de gesti√≥n utilizan P.O.O para organizar **ventanas, men√∫s, botones y acciones como objetos.** 
  
- üåê **2)Aplicaciones web y m√≥viles:**  
  Frameworks modernos aplican principios de programacion a objetos para manejar usuarios,productos,pedidos,mensajes,etc.

- üóÑÔ∏è **3)Sistemas de bases de datos:**  
  La P.O.O. se utiliza en el dise√±o de **bases de datos orientadas a objetos** y en los **ORM (Object-Relational Mapping)**, que permiten mapear tablas a objetos de manera sencilla.  
  Ejemplos: *SQLAlchemy (Python)*, *Hibernate (Java)*, *Entity Framework (.NET)*.

- üéÆ **4)Videojuegos:**  
  Cada **personaje, enemigo, escenario o arma** puede representarse como un **objeto** con atributos (vida, posici√≥n, puntuaci√≥n) y m√©todos (moverse, atacar, desaparecer).

- ü§ñ **5)Inteligencia Artificial y Simulaciones:**  
  Los **agentes inteligentes**, **redes neuronales** o **simulaciones f√≠sicas** se modelan como objetos que interact√∫an entre s√≠, compartiendo estados y comportamientos.

- ‚òÅÔ∏è **6)Sistemas distribuidos y en la nube:**  
  Los **servicios** se representan como objetos que se comunican entre diferentes nodos, manteniendo **modularidad y escalabilidad**.  
  Ejemplo: microservicios implementados con clases y objetos en *Python Flask* o *Java Spring*.

- üñ•Ô∏è **/)Interfaces gr√°ficas de usuario (GUI):**  
  Librer√≠as como **Tkinter (Python)**, **JavaFX (Java)** y **Qt (C++)** organizan elementos gr√°ficos (botones, men√∫s, cuadros de texto) como **objetos reutilizables** con propiedades y m√©todos.

---

### üß† Conclusi√≥n

La **P.O.O.** se aplica en cualquier √°rea donde se requiera **organizar y modular entidades complejas del mundo real**.  
Es el **paradigma principal del desarrollo de software moderno**, debido a su **claridad, escalabilidad y capacidad de reutilizaci√≥n**.



### üîπ Clase

Una **clase** es una **plantilla o molde** que permite crear **objetos**.  
-Define **atributos** (propiedades o caracter√≠sticas)
-Define **m√©todos** (acciones o comportamientos).

Los objetos son instancias de una clase es decir ,representaciones concretas creadas a partir de esa plantilla.
En otras palabras la clase es el molde la de la plantilla.

-El objeto es el productor creado apartir de ese molde.

# =======================================
# üß© EJEMPLO 1 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Coche` |
# | **Atributos** | `marca`, `modelo`, `color` |
# | **Comportamientos (m√©todos)** | `arrancar()`, `acelerar()`, `frenar()` |
# | **Objeto (instancia)** | `toyota = Coche("Toyota", "Corolla", "Blanco")` |
# =======================================

class Coche:
    def __init__(self, marca, modelo, color):
        self.marca = marca
        self.modelo = modelo
        self.color = color

    def arrancar(self):
        print(f"El {self.marca} {self.modelo} ha arrancado.")

    def acelerar(self):
        print(f"El {self.marca} {self.modelo} est√° acelerando... ¬°Vruum!")

    def frenar(self):
        print(f"El {self.marca} {self.modelo} est√° frenando.")


# =======================================
# üß© EJEMPLO 2 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Pitagoras` |
# | **Atributos** | `a`, `b` |
# | **Comportamiento (m√©todo)** | `calcular_hipotenusa()` |
# | **Objeto (instancia)** | `triangulo = Pitagoras(4, 3)` |
# =======================================

import math

class Pitagoras:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def calcular_hipotenusa(self):
        c = math.sqrt(self.a**2 + self.b**2)
        print(f"La hipotenusa es: {c:.2f}")
        return c


# =======================================
# üß© EJEMPLO 3 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Rectangulo` |
# | **Atributos** | `base`, `altura` |
# | **Comportamientos (m√©todos)** | `area()`, `perimetro()` |
# | **Objeto (instancia)** | `rect = Rectangulo(5, 6)` |
# =======================================

class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def area(self):
        return self.base * self.altura

    def perimetro(self):
        return 2 * (self.base + self.altura)


# =======================================
# üß© EJEMPLO 4 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Cantidad` |
# | **Atributos** | `longitud`, `altura`, `ancho`, `jv`, `sh` |
# | **Comportamiento (m√©todo)** | `calcular_ladrillos()` |
# | **Objeto (instancia)** | `pared = Cantidad(5, 2.5, 0.15, 0.015, 0.015)` |
# =======================================

class Cantidad:
    def __init__(self, longitud, altura, ancho, jv, sh):
        self.longitud = longitud
        self.altura = altura
        self.ancho = ancho
        self.jv = jv
        self.sh = sh

    def calcular_ladrillos(self):
        volumen_pared = self.longitud * self.altura * self.ancho
        volumen_ladrillo = (0.25 + self.jv) * (0.07 + self.sh) * (0.12 + self.jv)
        cantidad = volumen_pared / volumen_ladrillo
        print(f"Cantidad aproximada de ladrillos: {cantidad:.0f}")
        return cantidad
## üìòTEMA  _ ESTRUCTURA SELECTIVA
En el contexto de la programaci√≥n, una estructura selectiva es aquella que permite tomar decisiones autom√°ticas. Seg√∫n si se cumple o no una condici√≥n, se ejecutar√°n diferentes bloques de c√≥digo.
A diferencia de las estructuras selectivas que son esenciales en la programaci√≥n procedimental, los objetos en la Programaci√≥n Orientada a Objetos (POO) a menudo se basan en programas embebidos en las clases para controlar el flujo de ejecuci√≥n.
Definici√≥n: Una estructura selectiva en POO en Python es la construcci√≥n de m√©todos que permiten ejecutar diferentes l√≠neas de c√≥digo o llamar varios procedimientos, dependiendo de si se cumple una o varias condiciones dadas.
Tipos de Estructura Selectiva
## 1. Estructura Selectiva Simple:##
Se ejecuta un bloque de c√≥digo solo si se cumple la condici√≥n, en caso contrario, no hace nada.
Ejemplo:
if (x > 0):
    print("x es positivo")
## 2. Estructura Selectiva Doble:##
Permite dos ramas. Una si la condici√≥n es verdadera y otra si es falsa.
Ejemplo:
if (x % 2 == 0):
    print("x es un n√∫mero par")
else:
    print("x es un n√∫mero impar")

## 3. Estructura Selectiva M√∫ltiple:##
Gestiona m√°s de dos alternativas mutuamente exclusivas. Solo se ejecuta la primera condici√≥n verdadera.
Ejemplo:
if (x >= 90):
    print("Aprobado con distinci√≥n")
    ... (El ejemplo se corta aqu√≠, pero la estructura completa ser√≠a con elif y else)
    if (x >= 90):
    print("Aprobado con distinci√≥n")
elif (x >= 70):
    print("Aprobado")
else:
    print("Reprobado")

  # =======================================
# üß© EJEMPLO 1 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Numero` |
# | **Atributos** | `valor` |
# | **Comportamiento (m√©todo)** | `clasificar()` |
# | **Objetos (instancias)** | `Numero(0)`, `Numero(2)`, `Numero(5)` |
# =======================================

class Numero:
    def __init__(self, valor):
        self.valor = valor

    def clasificar(self):
        if self.valor == 0:
            print(f"El n√∫mero {self.valor} es **neutro**.")
        elif self.valor % 2 == 0:
            print(f"El n√∫mero {self.valor} es **par**.")
        else:
            print(f"El n√∫mero {self.valor} es **impar**.")


# =======================================
# üß© EJEMPLO 2 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Persona` |
# | **Atributos** | `nombre`, `edad` |
# | **Comportamiento (m√©todo)** | `es_mayor_de_edad()` |
# | **Objeto (instancia)** | `persona1 = Persona("Mar√≠a", 20)` |
# =======================================

class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def es_mayor_de_edad(self):
        if self.edad >= 18:
            print(f"{self.nombre} tiene {self.edad} a√±os ‚Üí Es **mayor de edad** ‚úÖ.")
        else:
            print(f"{self.nombre} tiene {self.edad} a√±os ‚Üí Es **menor de edad** ‚ùå.")



# =======================================
# üß© EJEMPLO 3 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Empleado` |
# | **Atributos** | `nombre`, `cargo`, `sueldo` |
# | **Comportamiento (m√©todo)** | `aplicar_aumento()` |
# | **Objeto (instancia)** | `empleado1 = Empleado("Carlos", "Gerente", 2000)` |
# =======================================

class Empleado:
    def __init__(self, nombre, cargo, sueldo):
        self.nombre = nombre
        self.cargo = cargo
        self.sueldo = sueldo

    def aplicar_aumento(self):
        if self.cargo.lower() == "gerente":
            aumento = 0.10
        elif self.cargo.lower() == "supervisor":
            aumento = 0.07
        elif self.cargo.lower() == "operario":
            aumento = 0.05
        else:
            aumento = 0.03  # aumento general por defecto

        nuevo_sueldo = self.sueldo * (1 + aumento)
        print(f"{self.nombre} ({self.cargo}) ‚Üí Sueldo anterior: {self.sueldo} | Nuevo sueldo: {nuevo_sueldo:.2f}")
        return nuevo_sueldo

# =======================================
# üß© EJEMPLO 4 - SIGNOS ZODIACALES 
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Zodiaco` |
# | **Atributos** | `dia`, `mes` |
# | **Comportamiento (m√©todo)** | `determinar_signo()` |
# | **Objetos (instancias)** | `Zodiaco(15, 5)` ‚Üí Tauro |
# =======================================

class Zodiaco:
    def __init__(self, dia, mes):
        self.dia = dia
        self.mes = mes

    def determinar_signo(self):
        if (self.mes == 3 and self.dia >= 21) or (self.mes == 4 and self.dia <= 19):
            signo = "Aries ‚ôà"
        elif (self.mes == 4 and self.dia >= 20) or (self.mes == 5 and self.dia <= 20):
            signo = "Tauro ‚ôâ"
        elif (self.mes == 5 and self.dia >= 21) or (self.mes == 6 and self.dia <= 20):
            signo = "G√©minis ‚ôä"
        elif (self.mes == 6 and self.dia >= 21) or (self.mes == 7 and self.dia <= 22):
            signo = "C√°ncer ‚ôã"
        elif (self.mes == 7 and self.dia >= 23) or (self.mes == 8 and self.dia <= 22):
            signo = "Leo ‚ôå"
        elif (self.mes == 8 and self.dia >= 23) or (self.mes == 9 and self.dia <= 22):
            signo = "Virgo ‚ôç"
        elif (self.mes == 9 and self.dia >= 23) or (self.mes == 10 and self.dia <= 22):
            signo = "Libra ‚ôé"
        elif (self.mes == 10 and self.dia >= 23) or (self.mes == 11 and self.dia <= 21):
            signo = "Escorpio ‚ôè"
        elif (self.mes == 11 and self.dia >= 22) or (self.mes == 12 and self.dia <= 21):
            signo = "Sagitario ‚ôê"
        elif (self.mes == 12 and self.dia >= 22) or (self.mes == 1 and self.dia <= 19):
            signo = "Capricornio ‚ôë"
        elif (self.mes == 1 and self.dia >= 20) or (self.mes == 2 and self.dia <= 18):
            signo = "Acuario ‚ôí"
        elif (self.mes == 2 and self.dia >= 19) or (self.mes == 3 and self.dia <= 20):
            signo = "Piscis ‚ôì"
        else:
            signo = "Fecha inv√°lida ‚ùå"

        print(f"Fecha: {self.dia}/{self.mes} ‚Üí Signo zodiacal: {signo}")
        return signo

## üìòTEMA  _ ESTRUCTURA REPETITIVA
En Python, estas estructuras (tambi√©n llamadas bucle o loops) repiten instrucciones que permiten ejecutar un bloque de c√≥digo varias veces dependiendo de una condici√≥n o una secuencia de elementos. Las dos estructuras repetitivas en Python son:
## 1. while (mientras):
Ejecuta un bloque de c√≥digo mientras una condici√≥n sea verdadera.
Ejemplo:
       contador = 0
while (contador < 5):
    print(contador)
    contador = contador + 1
## 2. for (para):
Se utiliza para iterar una secuencia (como una lista, tupla, string o rango de n√∫meros).
Ejemplo:
      for i in range(5):
    print(i)
# =======================================
# üß© EJEMPLO 5 - FACTORIAL
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Factorial` |
# | **Atributos** | `numero`, `resultado` |
# | **Comportamiento (m√©todo)** | `calcular()` |
# | **Objeto (instancia)** | `factorial = Factorial(5)` |
# =======================================

class Factorial:
    def __init__(self, numero):
        self.numero = numero
        self.resultado = 1

    def calcular(self):
        if self.numero < 0:
            print("No existe el factorial de un n√∫mero negativo ‚ùå")
            return None
        elif self.numero == 0 or self.numero == 1:
            self.resultado = 1
        else:
            for i in range(1, self.numero + 1):
                self.resultado *= i

        print(f"El factorial de {self.numero} es: {self.resultado}")
        return self.resultado

# =======================================
# üß© EJEMPLO 6 - SERIE DE FIBONACCI
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Fibonacci` |
# | **Atributos** | `n` (n√∫mero de t√©rminos) |
# | **Comportamiento (m√©todo)** | `generar_serie()` |
# | **Objeto (instancia)** | `miFibonacci = Fibonacci(10)` |
# =======================================

class Fibonacci:
    def __init__(self, n):
        self.n = n

    def generar_serie(self):
        serie = [0, 1]
        while len(serie) < self.n:
            serie.append(serie[-1] + serie[-2])
        print(f"Serie Fibonacci ({self.n} t√©rminos): {serie}")
        return serie


# =======================================
# üß© EJEMPLO 7 - TABLAS DE MULTIPLICAR
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `TablaMultiplicar` |
# | **Atributo** | `numero` |
# | **Comportamiento (m√©todo)** | `generar_tabla()` |
# | **Objeto (instancia)** | `tabla = TablaMultiplicar(9)` |
# =======================================

class TablaMultiplicar:
    def __init__(self, numero):
        self.numero = numero

    def generar_tabla(self):
        print(f"Tabla de multiplicar del {self.numero}:")
        for i in range(1, 11):
            print(f"{self.numero} x {i} = {self.numero * i}")


# =======================================
# üß© EJEMPLO 8 - SUMATORIA
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `SumaLista` |
# | **Atributo** | `lista` |
# | **Comportamiento (m√©todo)** | `calcular_suma()` |
# | **Objeto (instancia)** | `miSuma = SumaLista([4, 2, 3, 1, 10])` |
# =======================================

class SumaLista:
    def __init__(self, lista):
        self.lista = lista

    def calcular_suma(self):
        suma = sum(self.lista)
        print(f"Lista: {self.lista}")
        print(f"Suma total: {suma}")
        return suma


# =======================================
# üß© EJEMPLO 9 - ESTAD√çSTICA
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Estadistica` |
# | **Atributo** | `numeros` |
# | **Comportamientos (m√©todos)** | `calcular_media()`, `calcular_mediana()`, `calcular_suma()` |
# | **Objeto (instancia)** | `miEstadistica = Estadistica([10, 20, 30, 40, 50])` |
# =======================================

import statistics

class Estadistica:
    def __init__(self, numeros):
        self.numeros = numeros

    def calcular_media(self):
        return statistics.mean(self.numeros)

    def calcular_mediana(self):
        return statistics.median(self.numeros)

    def calcular_suma(self):
        return sum(self.numeros)

    def mostrar_resultados(self):
        print(f"N√∫meros: {self.numeros}")
        print(f"Media: {self.calcular_media()}")
        print(f"Mediana: {self.calcular_mediana()}")
        print(f"Suma: {self.calcular_suma()}")

# =======================================
# üß© EJEMPLO 10 - INGRESO DE DATOS Y C√ÅLCULO
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase 1** | `Entrada` |
# | **Atributo** | `valor` |
# | **Comportamiento (m√©todo)** | `ingresar()` |
# | **Clase 2** | `Calculador` |
# | **Atributos** | `numeros` |
# | **Comportamientos (m√©todos)** | `calcular_media()`, `calcular_suma()` |
# | **Objeto (instancia)** | `dato1 = Entrada(Calculador)` |
# =======================================

class Calculador:
    def __init__(self, numeros):
        self.numeros = numeros

    def calcular_media(self):
        return sum(self.numeros) / len(self.numeros)

    def calcular_suma(self):
        return sum(self.numeros)

    def mostrar_resultados(self):
        print(f"N√∫meros: {self.numeros}")
        print(f"Suma: {self.calcular_suma()}")
        print(f"Media: {self.calcular_media():.2f}")


class Entrada:
    def __init__(self, calculador):
        self.calculador = calculador

    def ingresar(self):
        print("üîπ Ingreso de datos completado. Resultados:")
        self.calculador.mostrar_resultados()
# =======================================
# üß© EJEMPLO 9 - SERIE DE FIBONACCI
# =======================================
class Fibonacci:
    def __init__(self, cantidad):
        self.cantidad = cantidad
        self.a = 0
        self.b = 1
        self.contador = 0

    def generar_serie(self):
        print("Serie Fibonacci:")
        while self.contador < self.cantidad:
            print(self.a, end=" ")
            c = self.a + self.b
            self.a = self.b
            self.b = c
            self.contador += 1
        print()

miFibonacci = Fibonacci(10)
miFibonacci.generar_serie()


# =======================================
# üß© EJEMPLO 10 - TABLA DE MULTIPLICAR
# =======================================
class TablaMultiplicar:
    def __init__(self, numero):
        self.numero = numero

    def generar_tabla(self):
        print(f"\nTabla de multiplicar del {self.numero}")
        for i in range(1, 11):
            print(f"{self.numero} x {i} = {self.numero * i}")

tabla = TablaMultiplicar(9)
tabla.generar_tabla()


# =======================================
# üß© EJEMPLO 11 - SUMATORIA
# =======================================
class SumaLista:
    def __init__(self, lista):
        self.lista = lista

    def calcular_suma(self):
        print(f"La suma de {self.lista} es: {sum(self.lista)}")

miSuma = SumaLista([4, 2, 3, 1, 10])
miSuma.calcular_suma()


# =======================================
# üß© EJEMPLO 12 - ESTAD√çSTICA
# =======================================
import statistics
class Estadistica:
    def __init__(self, numeros):
        self.numeros = numeros

    def mostrar_datos(self):
        media = statistics.mean(self.numeros)
        mediana = statistics.median(self.numeros)
        suma = sum(self.numeros)
        print(f"N√∫meros: {self.numeros}")
        print(f"Media: {media}, Mediana: {mediana}, Suma: {suma}")

miEstadistica = Estadistica([10, 20, 30, 40, 50])
miEstadistica.mostrar_datos()


# =======================================
# üß© EJEMPLO 13 - GESTOR DE TAREAS
# =======================================
class GestorDeTareas:
    def __init__(self):
        self.tareas = []

    def agregar_tarea(self, tarea):
        self.tareas.append(tarea)
        print(f"Tarea '{tarea}' agregada ‚úÖ")

    def eliminar_tarea(self, tarea):
        if tarea in self.tareas:
            self.tareas.remove(tarea)
            print(f"Tarea '{tarea}' eliminada ‚ùå")
        else:
            print("La tarea no existe en la lista.")

    def mostrar_tareas(self):
        print("\nüìã Lista de tareas:")
        for i, tarea in enumerate(self.tareas, 1):
            print(f"{i}. {tarea}")

miGestor = GestorDeTareas()
miGestor.agregar_tarea("Estudiar Python")
miGestor.agregar_tarea("Hacer pr√°ctica de POO")
miGestor.mostrar_tareas()
miGestor.eliminar_tarea("Estudiar Python")
miGestor.mostrar_tareas()
## üìòTEMA  _ ENCAPSULAMIENTO
En Programaci√≥n Orientada a Objetos (POO), el encapsulamiento es un principio que permite ocultar o resguardar la informaci√≥n interna de un objeto. Esto se consigue limitando el acceso directo a algunos de sus componentes, exponiendo solo la interfaz necesaria de m√©todos p√∫blicos (visibles).
Definici√≥n:
El encapsulamiento agrupa los datos (atributos) y las operaciones (m√©todos) que manipulan esos datos dentro de una clase. Su funci√≥n principal es controlar y limitar el acceso y as√≠ proteger la estructura interna del objeto.
# Caracter√≠sticas:
-Ocultamiento de datos: Los atributos de una clase est√°n usualmente declarados como privados, lo que impide que se acceda directamente a ellos desde fuera de la clase.
-Servicios (M√©todos): Se utilizan m√©todos p√∫blicos (getters y setters) para permitir la lectura o escritura de los atributos si es necesario.
-Mejora de Seguridad y Mantenimiento: Al proteger los datos internos, se evita que el c√≥digo externo pueda modificarlos de forma incorrecta o inesperada.
#Ventajas:
Protege la integridad de los datos.
Permite cambiar la implementaci√≥n interna sin afectar el c√≥digo externo.
Favorece el dise√±o modular y la reutilizaci√≥n de c√≥digo.
‚öôÔ∏è GETTERS Y SETTERS 
# Los m√©todos Getters y Setters permiten controlar el acceso a los
# atributos privados de una clase (encapsulamiento).

# üëâ Getter: obtiene (lee) el valor de un atributo.
# üëâ Setter: modifica (escribe) el valor de un atributo, aplicando validaciones si es necesario.

# BENEFICIOS:
# ‚úÖ Evitan acceso directo a los atributos.
# ‚úÖ Protegen los datos con validaciones.
# ‚úÖ Mejoran la seguridad y mantenimiento del c√≥digo.

# üß© EJEMPLO 1 - Cuenta Bancaria
class CuentaBancaria:
    def __init__(self, titular, saldo):
        self.titular = titular
        self.__saldo = saldo  # atributo encapsulado (privado)

    # M√©todo para mostrar saldo
    def mostrar_saldo(self):
        print(f"üí∞ Saldo actual de {self.titular}: S/{self.__saldo}")

    # M√©todo setter (modificar saldo)
    def depositar(self, monto):
        if monto > 0:
            self.__saldo += monto
            print(f"Dep√≥sito exitoso: +S/{monto}")
        else:
            print("‚ùå El monto debe ser positivo.")

    # M√©todo para retirar
    def retirar(self, monto):
        if monto <= self.__saldo:
            self.__saldo -= monto
            print(f"Retiro exitoso: -S/{monto}")
        else:
            print("‚ùå Fondos insuficientes.")

# Crear objeto
cuenta1 = CuentaBancaria("Gleny", 500)
cuenta1.mostrar_saldo()
cuenta1.depositar(200)
cuenta1.retirar(100)
cuenta1.mostrar_saldo()

# Intentar acceder directamente (no recomendado)
# print(cuenta1.__saldo)  # ‚ùå Error: atributo privado


# üß© EJEMPLO 2 - Alumno (con Getters y Setters)
class Alumno:
    def __init__(self, nombre, nota):
        self.__nombre = nombre
        self.__nota = nota

    # Getter para nombre
    def get_nombre(self):
        return self.__nombre

    # Setter para nombre
    def set_nombre(self, nuevo_nombre):
        self.__nombre = nuevo_nombre

    # Getter para nota
    def get_nota(self):
        return self.__nota

    # Setter para nota con validaci√≥n
    def set_nota(self, nueva_nota):
        if 0 <= nueva_nota <= 20:
            self.__nota = nueva_nota
        else:
            print("‚ùå La nota debe estar entre 0 y 20.")

    def mostrar_datos(self):
        print(f"üë©‚Äçüéì Alumno: {self.__nombre} | Nota: {self.__nota}")

# Uso del encapsulamiento
alumno1 = Alumno("Mar√≠a", 18)
alumno1.mostrar_datos()

alumno1.set_nota(21)      # No permite valor inv√°lido
alumno1.set_nota(15)
alumno1.set_nombre("Gleny")
alumno1.mostrar_datos()


# üß© EJEMPLO 3 - Producto con Descuento
class Producto:
    def __init__(self, nombre, precio):
        self.__nombre = nombre
        self.__precio = precio

    # Getter
    def get_precio(self):
        return self.__precio

    # Setter (con descuento)
    def aplicar_descuento(self, porcentaje):
        if 0 < porcentaje < 100:
            descuento = self.__precio * (porcentaje / 100)
            self.__precio -= descuento
            print(f"üõçÔ∏è Descuento aplicado: {porcentaje}% - Nuevo precio: S/{self.__precio:.2f}")
        else:
            print("‚ùå Porcentaje inv√°lido.")

    def mostrar_producto(self):
        print(f"üßæ Producto: {self.__nombre} | Precio: S/{self.__precio:.2f}")

# Uso
producto1 = Producto("Perfume Yanbal", 120)
producto1.mostrar_producto()
producto1.aplicar_descuento(20)
producto1.mostrar_producto()


# üß© EJEMPLO 4 - Temperatura (controlada)
class Temperatura:
    def __init__(self):
        self.__celsius = 0

    # Getter
    def get_celsius(self):
        return self.__celsius

    # Setter con validaci√≥n
    def set_celsius(self, valor):
        if valor < -273.15:
            print("‚ùÑÔ∏è Error: No puede ser menor que el cero absoluto (-273.15¬∞C)")
        else:
            self.__celsius = valor

    # Conversi√≥n a Fahrenheit
    def a_fahrenheit(self):
        return (self.__celsius * 9/5) + 32

## üìòTEMA  _ METODOS Y SOBRECARGAS
# Los M√âTODOS son funciones que se definen dentro de una clase
# y describen los comportamientos o acciones de los objetos.
#
# Los m√©todos pueden recibir par√°metros, devolver valores,
# y operar sobre los atributos de la clase.
# =======================================


# üß© EJEMPLO 1 - M√âTODOS B√ÅSICOS
# =======================================
# | Elemento | Descripci√≥n |
# |-----------|-------------|
# | **Clase** | `Persona` |
# | **Atributos** | `nombre` |
# | **M√©todos** | `saludar()` |
# | **Objeto** | `persona1 = Persona("Carlos")` |
# =======================================

class Persona:
    def __init__(self, nombre):
        self.nombre = nombre
    
    def saludar(self):
        print(f"üëã Hola, soy {self.nombre}")

# Crear objeto
persona1 = Persona("Carlos")
persona1.saludar()


# üß© EJEMPLO 2 - M√âTODOS CON PAR√ÅMETROS
# =======================================
# Los m√©todos pueden recibir datos externos al objeto.
# En todo m√©todo, el primer par√°metro es `self`, que representa al objeto.
# =======================================

class Calculadora:
    def sumar(self, a, b):
        return a + b

# Crear objeto
calculadora1 = Calculadora()
print(f"üßÆ La suma es: {calculadora1.sumar(4, 3)}")


# üß© RETORNO DE M√âTODOS
# =======================================
# El `return` permite devolver valores que pueden ser
# usados por otras partes del programa.
# =======================================

class Cuadrado:
    def __init__(self, lado):
        self.lado = lado

    def calcular_area(self):
        return self.lado * self.lado

figura = Cuadrado(5)
print(f"üìè El √°rea del cuadrado es: {figura.calcular_area()}")


# üß© SOBRECARGA DE M√âTODOS

# La sobrecarga de m√©todos permite definir varios m√©todos con el mismo nombre
# pero con diferentes par√°metros.
#
# En Python, no existe sobrecarga estricta como en Java o C++,
# pero se puede simular con valores predeterminados o *args.



# üß© EJEMPLO 3 - SOBRECARGA USANDO *args
class Operaciones:
    def sumar(self, *valores):
        if len(valores) == 2:
            return valores[0] + valores[1]
        elif len(valores) == 3:
            return valores[0] + valores[1] + valores[2]
        else:
            return "‚ö†Ô∏è Error: Cantidad de argumentos incorrecta."

# Uso
op = Operaciones()
print(f"Resultado (2 valores): {op.sumar(5, 7)}")
print(f"Resultado (3 valores): {op.sumar(2, 4, 6)}")


# üß© EJEMPLO 4 - CLASE RECT√ÅNGULO (con simulaci√≥n de sobrecarga)
class Rectangulo:
    def __init__(self, base=None, altura=None):
        self.base = base
        self.altura = altura

    def calcular_area(self, lado=None):
        # Si recibe un argumento, se trata de un cuadrado
        if lado is not None:
            return lado * lado
        # Si tiene base y altura, se trata de un rect√°ngulo
        elif self.base and self.altura:
            return self.base * self.altura
        else:
            return "‚ùå Datos insuficientes para calcular el √°rea."

# Uso
r1 = Rectangulo(4, 5)
print(f"Rect√°ngulo: √Årea = {r1.calcular_area()}")
r2 = Rectangulo()
print(f"Cuadrado: √Årea = {r2.calcular_area(10)}")


# üß© EJEMPLO 5 - CLASE C√çRCULO
import math
class Circulo:
    def __init__(self, radio):
        self.radio = radio
    
    def calcular_area(self):
        return math.pi * self.radio ** 2
    
    def calcular_perimetro(self):
        return 2 * math.pi * self.radio
    
    def mostrar_informacion(self):
        print(f"‚ö™ Radio: {self.radio}")
        print(f"√Årea: {self.calcular_area():.2f}")
        print(f"Per√≠metro: {self.calcular_perimetro():.2f}")

# Uso
c1 = Circulo(6)
c1.mostrar_informacion()


# üß© EJEMPLO 6 - CLASE TRI√ÅNGULO
import math
class Triangulo:
    def __init__(self, a, b):
        self.a = a
        self.b = b
    
    def calcular_hipotenusa(self):
        return math.sqrt(self.a ** 2 + self.b ** 2)
    
    def mostrar_informacion(self):
        print(f"üî∫ Cateto a: {self.a}")
        print(f"Cateto b: {self.b}")
        print(f"Hipotenusa: {self.calcular_hipotenusa():.2f}")
## üìòTEMA  _ METODO OPERATIVO 
Un **m√©todo operativo** es una **funci√≥n definida dentro de una clase** que realiza una acci√≥n o proceso espec√≠fico sobre los **atributos del objeto** o los **par√°metros externos** que recibe.

üìò En resumen:  
Un m√©todo operativo ‚Äú**hace algo**‚Äù ‚Äî calcula, imprime, suma, resta, muestra informaci√≥n, etc.
| S√≠mbolo | Operador | Descripci√≥n |
|----------|-----------|-------------|
| `__str__` | `print()` | Mostrar informaci√≥n legible del objeto |
| `__eq__` | `==` | Comparar dos objetos |
| `__gt__` | `>` | Verificar si un objeto es mayor que otro |
| `__add__` | `+` | Sumar o combinar objetos |

## üß† Estructura General
class NombreClase:
    def __init__(self, atributos):
        self.atributo = atributos

    def metodo_operativo(self, parametros):
        return resultado
        
üßÆ Ejemplo 1: Clase Calculadora
python
Copiar c√≥digo
class Calculadora:
    def __init__(self):
        pass
 # M√©todo operativo que suma dos n√∫meros
    def sumar(self, a, b):
        return a + b
# M√©todo operativo que multiplica dos n√∫meros
    def multiplicar(self, a, b):
        return a * b

# #üìè Ejemplo 2: Clase Rect√°ngulo
python
Copiar c√≥digo
class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    # M√©todo operativo: calcula el √°rea
    def calcular_area(self):
        return self.base * self.altura

    # M√©todo operativo: calcula el per√≠metro
    def calcular_perimetro(self):
        return 2 * (self.base + self.altura)


# Uso
r1 = Rectangulo(4, 5)
print(f"üìê √Årea: {r1.calcular_area()}")
print(f"üî≤ Per√≠metro: {r1.calcular_perimetro()}")
‚úÖ Descripci√≥n:
Los m√©todos calcular_area() y calcular_perimetro() usan los atributos del objeto para realizar operaciones.

üè¶ Ejemplo 3: Clase Banco (Dep√≥sitos y Retiros)
python
Copiar c√≥digo
class Banco:
    def __init__(self, titular, saldo):
        self.titular = titular
        self.saldo = saldo
    def depositar(self, monto):
        self.saldo += monto
        print(f"üí∞ Dep√≥sito exitoso. Nuevo saldo: {self.saldo}")
    def retirar(self, monto):
        if monto <= self.saldo:
            self.saldo -= monto
            print(f"üè¶ Retiro exitoso. Nuevo saldo: {self.saldo}")
        else:
            print("‚ùå Saldo insuficiente.")


# Uso
cuenta1 = Banco("Gleny", 500)
cuenta1.depositar(300)
cuenta1.retirar(200)
‚úÖ Descripci√≥n:
Los m√©todos depositar() y retirar() son operativos porque ejecutan acciones concretas que modifican el estado del objeto.

‚öóÔ∏è Ejemplo 4: Clase Persona (M√©todo Operativo con Retorno)
python
Copiar c√≥digo
class Persona:
    def __init__(self, nombre):
        self.nombre = nombre

    def saludar(self):
        return f"Hola, soy {self.nombre}"


# Uso
persona1 = Persona("Carlos")
print(persona1.saludar())
‚úÖ Explicaci√≥n:
El m√©todo saludar() no necesita par√°metros externos; act√∫a directamente sobre el atributo nombre.

üí° Ejemplo 5: Clase Calculadora con Encabezados
python
Copiar c√≥digo
class Calculadora:
    def sumar(self, a, b):
        return a + b

calculadora1 = Calculadora()
print(f"La suma es: {calculadora1.sumar(4, 3)}")
‚úÖ Nota:
Los m√©todos pueden recibir par√°metros externos y siempre incluyen self como primer par√°metro para representar al objeto mismo.

üåÄ Ejemplo 6: Sobrecarga de M√©todos
En Python, la sobrecarga no existe de forma estricta como en otros lenguajes (Java o C++),
pero se puede simular usando par√°metros variables (*args o valores por defecto).

üîπ Ejemplo: Clase Operaciones
python
Copiar c√≥digo
class Operaciones:
    def sumar(self, *valores):
        if len(valores) == 2:
            return valores[0] + valores[1]
        elif len(valores) == 3:
            return valores[0] + valores[1] + valores[2]
        else:
            return "Error: cantidad de argumentos incorrecta"

üìê Ejemplo 7: Clase Rect√°ngulo (√Årea y Sobrecarga)
python
Copiar c√≥digo
class Rectangulo:
    def __init__(self, base=0, altura=0):
        self.base = base
        self.altura = altura
    def calcular_area(self, lado=None):
        if lado is not None:
            return lado * lado
        else:
            return self.base * self.altura


üîµ Ejemplo 8: Clase C√≠rculo
python
Copiar c√≥digo
import math

class Circulo:
    def __init__(self, radio):
        self.radio = radio

    def calcular_area(self):
        return math.pi * self.radio ** 2

    def calcular_perimetro(self):
        return 2 * math.pi * self.radio

    def mostrar_informacion(self):
        print(f"üîµ Radio: {self.radio}")
        print(f"üìè √Årea: {self.calcular_area():.2f}")
        print(f"üìè Per√≠metro: {self.calcular_perimetro():.2f}")

üî∫ Ejemplo 9: Clase Tri√°ngulo (Teorema de Pit√°goras)
python
Copiar c√≥digo
import math

class Triangulo:
    def __init__(self, a, b):
        self.a = a
        self.b = b

    def calcular_hipotenusa(self):
        return math.sqrt(self.a ** 2 + self.b ** 2)

    def mostrar_informacion(self):
        print(f"Cateto a: {self.a}")
        print(f"Cateto b: {self.b}")
        print(f"Hipotenusa: {self.calcular_hipotenusa():.2f}")



## üìòTEMA  _ CONSTRUIR Y DESTRUIR
 **CONSTRUCTOR**

Un **constructor** es un m√©todo especial que se ejecuta **autom√°ticamente** al **crear** (instanciar) un objeto de una clase.  
Se utiliza para **inicializar los atributos** del objeto.

### üîπ Sintaxis:
def __init__(self, ...):
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
        print(f"Se ha creado a {self.nombre}, de {self.edad} a√±os.")

class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
        print(f"Se ha creado a {self.nombre}, de {self.edad} a√±os.")
persona1 = Persona("Gleny", 20)

### üîπ DESTRUCTOR:

El destructor es un m√©todo especial que se ejecuta autom√°ticamente cuando un objeto est√° a punto de ser eliminado o ya no se usa m√°s.
Sirve para liberar recursos o mostrar mensajes antes de la eliminaci√≥n.
SINTAXIS
def __del__(self):
    # C√≥digo de limpieza o mensaje final
EJEMPLO
class Persona:
    def __init__(self, nombre):
        self.nombre = nombre
        print(f"El objeto {self.nombre} ha sido creado.")

    def __del__(self):
        print(f"El objeto {self.nombre} fue eliminado.")

# Crear y eliminar objeto
persona1 = Persona("Carlos")
del persona1
üîÑ CICLO DE VIDA DE UN OBJETO

El ciclo de vida de un objeto describe las etapas que atraviesa un objeto desde su creaci√≥n hasta su destrucci√≥n.

Etapa	Descripci√≥n	M√©todo Relacionado
üß± Creaci√≥n	El objeto se construye e inicializa.	__init__()
‚öôÔ∏è Uso	Se ejecutan m√©todos y se accede a los atributos.	M√©todos definidos en la clase
üßπ Destrucci√≥n	El objeto se elimina de la memoria.	__del__()
üîπ Ejemplo Completo del Ciclo de Vida
class EjemploCiclo:
    def __init__(self, nombre):
        self.nombre = nombre
        print(f"üß± Objeto '{self.nombre}' creado.")

    def usar(self):
        print(f"‚öôÔ∏è Usando el objeto '{self.nombre}'.")

    def __del__(self):
        print(f"üßπ Objeto '{self.nombre}' destruido.")

# Ciclo de vida
objeto = EjemploCiclo("Prueba")
objeto.usar()
del objeto


‚úÖ Salida esperada:

üß± Objeto 'Prueba' creado.
‚öôÔ∏è Usando el objeto 'Prueba'.
üßπ Objeto 'Prueba' destruido.


## üìòTEMA  _ Relaciones entre Clases
En la Programaci√≥n Orientada a Objetos en Python, las relaciones permiten modelar c√≥mo los objetos interact√∫an entre s√≠ en un sistema. Existen 3 relaciones fundamentales que indican c√≥mo una clase puede relacionarse con otra:
1. AGREGACI√ìN
Es una relaci√≥n general entre dos clases, donde una utiliza a otra. Esta relaci√≥n no implica propiedad o dependencia fuerte.
CARACTER√çSTICAS:
 * Los objetos est√°n relacionados pero son independientes.
 * Puede ser unidireccional o bidireccional.
 * Se basa en el uso de instancias de otra clase.
2. COMPOSICI√ìN
La agregaci√≥n es un tipo especial de relaci√≥n de todo-parte, donde una clase (el todo) contiene a las partes (la parte), pero las partes pueden existir independientemente del todo.
CARACTER√çSTICAS:
 * Relaci√≥n tiene un (has-a).
 * El objeto contenido no es destruido si el objeto contenedor desaparece.
 * Los objetos se pueden reutilizar en otras partes.
3. COMPOSICI√ìN:
Es un caso m√°s fuerte que la agregaci√≥n. Tambi√©n es una relaci√≥n (todo-parte) pero con propiedad total y dependencia de ciclo de vida. Si el objeto contenedor se destruye, las partes tambi√©n.
CARACTER√çSTICAS:
 * Relaci√≥n fuerte de pertenencia.
 * Se crean y destruyen con el objeto contenedor.

=================================================================
## UNIDAD II ##
=================================================================
# üß© TEMA: Herencia en Programaci√≥n Orientada a Objetos (P.O.O)

## üìò Herencia
La **herencia** es un concepto fundamental en la Programaci√≥n Orientada a Objetos (P.O.O) que permite crear nuevas clases a partir de clases existentes.  
La clase nueva (llamada **clase derivada** o **subclase**) hereda atributos y m√©todos de la clase original (llamada **clase base** o **superclase**).
üëâ Esto facilita:
- La reutilizaci√≥n de c√≥digo.  
- La organizaci√≥n jer√°rquica de las clases.  
- La extensi√≥n del comportamiento sin necesidad de reescribir c√≥digo.  

## üß† Herencia Simple

En la **herencia simple**, una clase derivada hereda de una √∫nica clase base.  
Esto significa que la subclase solo tiene una superclase directa, lo que la convierte en el tipo de herencia m√°s com√∫n y sencillo de implementar. 

## üß† Herencia Multiple

En la **herencia m√∫ltiple**, una clase puede heredar atributos y m√©todos de varias clases bases al mismo tiempo. Esto permite combinar funcionalidades de diferentes clases¬†en¬†una¬†sola.


## üóÇÔ∏è Ejemplo 
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  Persona   ‚îÇ   ‚Üê Superclase
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Alumno   ‚îÇ ‚îÇ Profesor ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
- **Persona** ‚Üí Superclase  
- **Alumno** ‚Üí Subclase  
- **Profesor** ‚Üí Subclase


# EJEMPLOS DE CODIGO #

--**CLASS ANIMAL**--

class Animal:
    def hacerSonido(self):
        print("Sonido gen√©rico")


class Perro(Animal):
    def ladrar(self):
        print("¬°Guau!")
perro = Perro()
perro.hacerSonido()  # M√©todo heredado de Animal
perro.ladrar()       # M√©todo propio de Perro


--**CLASS ANIMAL.2** --

class Animal: #clase base
    def _init_(self, nombre):
        self.nombre = nombre
        
    def hacerSonido(self):
        pass
    
class Perro(Animal): #herencia derivada

    def hacerSonido(self):
        return "Guau!"
class Gato(Animal): #herencia derivadda
    def hacerSonido(self):
        return "Miau!"
perro =Perro("Rex")
print(f"{perro.nombre} dice {perro.hacerSonido()}")
gato =Gato("Iris")
print(f"{gato.nombre} dice {gato.hacerSonido()}")


--**CLASS FIGURA GEOMETRICA CIRCULO**--
class FiguraGeometrica:
    def __init__(self, nombre):
        self.nombre = nombre

    def area(self):
        raise NotImplementedError("Subclases deben implementar este m√©todo")

    def perimetro(self):
        raise NotImplementedError("Subclases deben implementar este m√©todo")

class Circulo(FiguraGeometrica):
    def __init__(self, radio):
        super().__init__("Circulo")
        self.radio = radio

    def area(self):
        return 3.141592*(self.radio**2)

    def perimetro(self):
        return 2*3.141592*self.radio

circulo = Circulo(5)
print(f"Nombre : {circulo.nombre}")
print(f"Area : {circulo.area()}")
print(f"Perimetro : {circulo.perimetro()}")

--**CLASS FIGURA GEOMETRICA RESCTANGULO**--
class FiguraGeometrica:
    def __init__(self, nombre):
        self.nombre = nombre

    def area(self):
        raise NotImplementedError("Subclases deben implementar este m√©todo")

    def perimetro(self):
        raise NotImplementedError("Subclases deben implementar este m√©todo")

class Rectangulo(FiguraGeometrica):
    def __init__(self, base, altura):
        super().__init__("Rectangulo")
        self.base = base
        self.altura = altura

    def area(self):
        # F√≥rmula del √°rea: base * altura
        return self.base * self.altura

    def perimetro(self):
        # F√≥rmula del per√≠metro: 2 * (base + altura)
        return 2 * (self.base + self.altura)

rectangulo = Rectangulo(10, 5) # Base = 10, Altura = 5
print(f"Nombre : {rectangulo.nombre}")
print(f"Area : {rectangulo.area()}")
print(f"Perimetro : {rectangulo.perimetro()}")


--**CLASS AVES SONIDO**--

class Nadador: #clase base 1
    def nadar(self):
        print("Nadando en el agua")

class Volador: #clase base 2
    def volar(self):
        print("volando por el aire")

class Pato(Nadador,Volador): #clase derivada
    def graznar(self):
        print("¬°Cuac!")

pato = Pato()
pato.nadar()
pato.volar()
pato.graznar()

--**CLASS AVES(CISNE)**--

cisne.nadar()
cisne.volar()
cisne.cantar()
class Nadador:  # Clase base 1
    def nadar(self):
        print("El cisne se desliza elegantemente en el agua.")


class Volador:  # Clase base 2
    def volar(self):
        print("El cisne surca el cielo con majestuosidad.")


class Cisne(Nadador, Volador):  # Clase derivada (Herencia m√∫ltiple)
    def cantar(self):
        print("¬°Whoop!")


# Crear objeto de la clase Cisne
cisne = Cisne()

# Llamar a los m√©todos heredados y propios
cisne.nadar()
cisne.volar()
cisne.cantar()
